<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scala=1.0"><meta name="description" content="This is RuiOliveiras personal blog, where i will right about interesting things"><title>RuiOliveiras &ndash; Personal Blog</title><link rel="stylesheet" href="/js//lib/prism.css"><link rel="stylesheet" href="/css/lib/pure.css"><link rel="stylesheet" href="/css/lib/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=EB+Garamond|Lobster|Sura"><!--link(rel='stylesheet' href='/css/blog.css')--><link rel="stylesheet" href="/css/side-bar.css"><link rel="stylesheet" href="/css/base.css"></head><body><div id="layout" class="pure-g active"><div id="" class="ros-sidebar pure-u-1 pure-u-lg-8-24">     <div class="ros-sidebar-content pure-u-20-24"><div class="brand-title pure-g"><div class="pure-u-2-5"><img src="/img/me.jpg" class="pure-img"></div><span class="pure-u-3-5"><a href="/" class="brand-title-text ros-super-cool-url">Rui Oliveiras</a></span></div><h2 class="brand-tagline">Menu</h2><nav class="nav"><ul class="nav-list"><li class="nav-item"><a href="/posts" class="ros-cool-url">Posts</a></li><li class="nav-item"><a href="/p1/bio.html" class="ros-cool-url">Bio</a></li><li class="nav-item"><a href="/cv.pdf" class="ros-cool-url">Curriculum</a></li><li class="nav-item"><a href="https://github.com/ruioliveiras/" class="ros-cool-url">Github</a></li></ul></nav><h2 class="brand-tagline">Summary</h2><nav class="nav"><ul class="nav-list"><li class="nav-item"><a href="#concepts" class="ros-cool-url">Concepts</a></li><ul class="nav-list"><li class="nav-item"><a href="#mutability-ummitability" class="ros-cool-url">Mutability and Immutability</a></li><li class="nav-item"><a href="#singleton" class="ros-cool-url">Singleton object</a></li></ul><li class="nav-item"><a href="#scala-oo" class="ros-cool-url">Scala as a Object Oriented Language</a></li><ul class="nav-list"><li class="nav-item"><a href="#objects-class" class="ros-cool-url">Objects and Class</a></li><li class="nav-item"><a href="#traits" class="ros-cool-url">Traits</a></li><li class="nav-item"><a href="#case-class" class="ros-cool-url">Case Class</a></li><li class="nav-item"><a href="#generic-class" class="ros-cool-url">Generic Class</a></li></ul><li class="nav-item"><a href="#scala-functional" class="ros-cool-url">Scala as a Functional language</a></li><ul class="nav-list"><li class="nav-item"><a href="#var-val" class="ros-cool-url">Var and Val</a></li><li class="nav-item"><a href="#higter-order" class="ros-cool-url">Higter order functions</a></li><li class="nav-item"><a href="#collections-functions" class="ros-cool-url">Collections functions</a></li><li class="nav-item"><a href="#-implicit-variable" class="ros-cool-url">Implicit Variable</a></li><li class="nav-item"><a href="#-implicit-method" class="ros-cool-url">Implicit Method</a></li><li class="nav-item"><a href="#-implicit-class" class="ros-cool-url">Implicit Class</a></li></ul><li class="nav-item"><a href="#scala-script" class="ros-cool-url">Scala as a Script language</a></li><ul class="nav-list"><li class="nav-item"><a href="#type-inference" class="ros-cool-url">Type Inference</a></li><li class="nav-item"><a href="#syntax-sugar" class="ros-cool-url">Syntax Sugar</a></li></ul></ul></nav></div><a href="#menu" id="menuLink" class="pure-u-4-24 menu-link"><span></span></a></div><div class="ros-content pure-u-1 pure-u-lg-16-24"><h1>Scala Language base Tutorial</h1><h4>Hot links</h4><p>Scala Oficial: <a href="http://www.scala-lang.org">http://www.scala-lang.org</a></p>
<p>Nice post: <a href="http://lampwww.epfl.ch/~michelou/scala/using-scala-from-java.html">http://lampwww.epfl.ch/~michelou/scala/using-scala-from-java.html</a></p>
<p><strong>How Install</strong>: <a href="http://www.scala-lang.org/download/install.html">http://www.scala-lang.org/download/install.html</a> ;</p>
<p>It is just:</p>
<ol>
<li>Download scala</li>
<li>Crete path variable $SCALA_HOME </li>
<li>Update the variable $PATH to have the $SCALA_HOME/bin
And you have the &#39;scala&#39; command wich gives you a Scala intepretor</li>
</ol>
<p><strong>Scala Ide</strong>: <a href="http://scala-ide.org">http://scala-ide.org</a>
(an easy way to install and work with scala)</p>
<p><strong>SBT</strong>: <a href="http://www.scala-sbt.org/">http://www.scala-sbt.org/</a>
Is the scala build tool which manage dependencies. Sbt is for scala like Maven is for JAVA.</p>
<h2>Introduction</h2><p>I will start with some generic concepts (<a href="#mutability-ummitability">Mutability and Immutability</a> and <a href="#singleton">Singleton object</a>) that are not specific of the scala language.</p>
<p>Next, I have separated the main features in 3 Charters:  <a href="#scala-oo">Scala as a Object Oriented Language</a>, <a href="#scala-functional">Scala as a Functional language</a>, <a href="#scala-script">Scala as a Script language</a>. 
I like to say that scala was the qualities of all kind paradigms.
It is possible to take advantage of each paradigm.</p>
<p>In the future I would like to pick some other topic: Reflection and Macros - this two things are still currently in experimental, but they are very cool and usable; 
Concurrency  which in Scala is very intuitive; 
Native XML scala feature;
and notes about string processing. </p>
<p>This tutorial is currently beeing writed in my free times, so in the end there are some topics which are not writed yet .</p>
<h2>Scala Ecosystem</h2><p>Tools</p>
<p><a name="concepts"></a></p>
<h2>Concepts</h2><p>Before we get started, we must know about a few general concepts. 
Concepts that are not specific from the Scala language but general from the programming.
But where in Scala they are more used or has more importance.</p>
<p><a name="mutability-ummitability"></a></p>
<h3>Mutability and Immutability</h3><p>Immutability is one of pillars of a functional language.</p>
<p><strong> Mutable variable </strong> its state can change over time.</p>
<p><strong> Immutable variable </strong> its state can&#39;t change over time.</p>
<p>Immutability advantages</p>
<ul>
<li>Is very good for concurrency (many threads changing the value of one variable at same time may be dangerous )</li>
<li>Code more clean</li>
</ul>
<p>Immutability disadvantages</p>
<ul>
<li>May be  costly to be recreating objects on each change</li>
</ul>
<p><a name="singleton"></a></p>
<h3>Singleton object</h3><p>Singleton objects are unique at the runtime. There will not exist at same time two instances of this objects types.</p>
<p>In Java, a class have its own static scope, where are declared static methods and variables. This static scope of the class, in java, are nothing more that a built-in singleton object</p>
<p>But in Scala there aren&#39;t the keyword static.
Instead there are classes and singleton objects, they are managed differently.</p>
<p><a name="scala-oo"></a></p>
<h2>Scala as a Object Oriented Language</h2><p>In Scala you can do everything that you already could do in JAVA, or in other Object oriented language.
The main difference could be that in Scala there aren&#39;t static scope variables. But an equivalent thing:
If you need a static variable for the class A, you create an object A in the same file, and place 
the variable there. </p>
<p><a name="objects-class"></a></p>
<h3>Objects and Class</h3><p><strong>Class</strong>: is equivalent to Java. </p>
<pre><code class="language-scala">// declaring a class you can create a default constructor. This constructor 
// define the constructor arguments and class Attribute at same time. 
class Example(favoriteNumber:Int, name:String) {
//  an attribute
private val dadFavoriteNumber:Int = favoriteNumber * 2
// defining other constructor, on this case calling the default constructor
def this(favoriteNumber:Long) = this(favoriteNumber.toInt, &quot;default-name&quot;);
// defining a method without arguments with Int Return
def dadNumber():Int = dadFavoriteNumber
// this is equivalent to
// def dadNumber():Int = {return dadFavoriteNumber; }
}
// instantiating with firt constructor
new Example(1, &quot;ruiOliveira&quot;).dadNumber()
// instantiating with second constructor
new Example(2l).dadNumber()
// 2l -&gt; is a scala way to create Longs
</code></pre>
<p>Run scala intepretor in the shell (command &#39;scala&#39;), and copy-paste this code and test.</p>
<p><strong>Object</strong>: is a tool that can be used in different situations.
One used situation is to work has a singleton, as you can see:</p>
<pre><code class="language-scala">// (Requires the Example class definition in the intepretor)

// a singleton object 
object Example{
// This variable can be seen has a static variable in Example 
var counter:Int = 10
// this method can be seend has a Static method in the Example
def counterPlusOne():Int ={ counter += 1; counter }  
// On this method we are creating a variable of class Example and using 
// the object Example. The compiler is very smart, and they know when 
// you are using the Class or when you are using the Object. Even if 
// they have the same name.
def newExample(name:String) = new Example(Example.counterPlusOne(), name);
}
val ro1 = Example.newExample(&quot;Rui Oliveira 1&quot;);
ro1.dadNumber()
val ro2 = Example.newExample(&quot;Rui Oliveira 2&quot;);
ro2.dadNumber()
val ro3 = Example.newExample(&quot;Rui Oliveira 3&quot;);
ro3.dadNumber()
// the dadNumber is growing,
</code></pre>
<p>Run scala intepretor in the shell (command &#39;scala&#39;), and copy-paste this code.</p>
<p>In scala a class don&#39;t have static methods or variables, what you can do is create a Object with the same name of the class, this object is called <strong>Companion object</strong></p>
<pre><code class="language-scala">// The class
class TheClass
// The companion object
oject TheClass
// PERSONAL NOTE: need intepretor validation
</code></pre>
<p><a name="traits"></a></p>
<h3>Traits</h3><p>A trait is a <strong>tool</strong>, a tool that can be compared to a JAVA interface. With the different
that you can have method implementations and variable initialization.</p>
<p>After the compilation, as trait is nothing more that a interface for the JVM. 
So the definitions of the method and variable will be the in the class that uses the trait.</p>
<p><strong>Creating a Trait</strong></p>
<pre><code class="language-scala">trait Person{
//who use this trait must define a value Name with type String
val name:String;
var nameCounter = 0
def getName():String = {
nameCounter += 1
// value name is the last thing of this block so will be returned 
// Keep this in mind, scala don&#39;t require return keyword 
name
}

def howManyTimesNameWasCalled() = nameCounter
}
// you can create an object with the same name has the trait
object Person{
  // you can variables of a spessfic Trait
  def testTraitPerson(p:Person) = {
println(p.howManyTimesNameWasCalled())
p.getName(); p.getName()
println(p.howManyTimesNameWasCalled())
  }

}
</code></pre>
<p><strong>Object using a Trait</strong>, note that we are defining name value.</p>
<pre><code class="language-scala">object RuiOliveira extends Person{
val name = &quot;rui Oliveira&quot;;
}
Person.testTraitPerson(RuiOliveira)
</code></pre>
<p>Has you can see a object is a variable that uses Person so it can be used in the testTraitPerson</p>
<p><strong>Class using a trait</strong>, note that we are declaring value &#39;name&#39; in the constructor parameters.</p>
<pre><code class="language-scala">class OtherPerson(val name:String) extends Person

val p = new OtherPerson(&quot;pedro&quot;)
Person.testTraitPerson(p)
</code></pre>
<p>Has was expected we can use traits in class&#39;s</p>
<p><strong>Trait on variable</strong>. (Anonymous declaration) </p>
<pre><code class="language-scala">// Dog are not Persons, so it don&#39;t extends to trait Person
class Dog(val dogName:String)

// but this specialDog are a Person, its type is &#39;Dog with Person&#39;
val specialDog:Dog with Person = new Dog(&quot;doggy&quot;) with Person {
val name = dogName;
}
Person.testTraitPerson(p)
</code></pre>
<p><a name="case-class"></a></p>
<h3>Case Class</h3><p>Case class are a &quot;modification&quot; to normal classes</p>
<pre><code class="language-scala">// normal class
class Onwer( name:String)
class Phone( number:String,  owner:Onwer)
// case class
case class Owner2( name:String)
case class Phone2( number:String, owner:Owner2)
</code></pre>
<p>Creating a case class you will be access:</p>
<ul>
<li>default create functions: toString, copy, equal and hashcode.</li>
<li>class will be immutable by default</li>
<li>default create singleton object with method unapplay and apply functions</li>
</ul>
<p><a name="apply-unapply"></a></p>
<h3>Methods <code>apply</code> and <code>unapply</code></h3><p>The methods <code>apply</code> and <code>unapply</code> are created in the companion object</p>
<pre><code class="language-scala">case class Person(name:String)

object Person {
  // methods create automaticly by case class:
  // def apply(name:String) = new Person(name)
  // def unapply()
}


// NEED intrepretor vadidation
</code></pre>
<p>!explain !
!Here explain the power of unapplay and apply!</p>
<p><a name="generic-class"></a></p>
<h3>Generic Class</h3><h3>Inner Class and Object</h3><p><a name="scala-functional"></a></p>
<h2>Scala as a Functional language</h2><p>On this section, there will be explained some of the Scala features that are related to Functional World:</p>
<ul>
<li>var and val (Mutability and Immutability)</li>
<li>Lambda functions</li>
<li>handling collection in a functional way</li>
<li>implicit things (variable, method and class) </li>
</ul>
<p><a name="var-val"></a></p>
<h3>Var and Val</h3><p>Var and Val keyword can be used to declare objects or in class parameter.</p>
<p><strong>var</strong> stands for variable
<strong>val</strong> stands for value</p>
<pre><code class="language-scala">var counter = 1;
val max = 100;

while(counter &lt; max) {
  counter += 1;
  // in scala there aren&#39;t ++ operator
}
</code></pre>
<p>On this example counter variable are being setted multiple times. While if you try to set a new value in the counter, it will gives you a compile error.</p>
<p>Usage on as a class parameter:</p>
<pre><code class="language-scala">class Person(val name:String, var age:Int) {
  def doBirthdate:Unit = age += 1;
}
</code></pre>
<p>The parameter name will never got changed while age can be changed.</p>
<p>Var and Val with class types</p>
<pre><code class="language-scala">class Club(val peopleList:List[Person], val owner:Person)
</code></pre>
<p>On this example we have the owner parameter as val, but this don&#39;t mean that we cannot use &#39;onwer.doBirthdate&#39; and change the state of owner.
When we set a parameter has val, we are telling the compiler that the &#39;symbol&#39; named &#39;owner&#39; will only be setted one time.</p>
<p>We say that a class is Immutable when all the parameters are &#39;val&#39; and all the parameters Types are also immutable.</p>
<p><a name="higter-order"></a></p>
<h3>Lambda functions</h3><p>The syntax to create a lambda function are:</p>
<pre><code class="language-scala">val f = (x:Int) =&gt; x*2
f(2) 
// will give 4
</code></pre>
<p>We can receive function as parameter</p>
<pre><code class="language-scala">val op1 = (x:Int, y:Int) =&gt; x * 2 + y
val f = (x:Int, y:Int, op: ((Int,Int) =&gt; Int) ) =&gt; op(x,y)
f(2,3,op1) 
// will give 7
</code></pre>
<p><a name="collections-functions"></a></p>
<h3>Collections functions</h3><p>To know more Collectons, check the Collection section. On this sub-section I will only 
explain the functinal approuch of the Collections</p>
<p><strong>Map</strong> Transforming a List into an other list with an operation</p>
<pre><code class="language-scala">val l:List[Int] = List(1,2,3,4);
val op = (x:Int) =&gt; x * 2
// running the operation &#39;op&#39; over each element 
val l2:List[Int] = l.map(op);
// l2 will have: List(2,4,6,8)
// l1 will keep the List(1,2,3,4)
</code></pre>
<p>With some systatix sugar (which i&#39;m gooing to explain in [ref section3]).
We can simplie write</p>
<pre><code class="language-scala">val l:List[Int] = List(1,2,3,4);
val l2:List[Int] = l.map({ x =&gt; x * 2});
val l3:List[Int] = l.map{ x =&gt; x * 2};
val l4:List[Int] = l.map(x =&gt; x * 2);
val l5:List[Int] = l.map(_ * 2);
// l2, l3, l4, l5 are exatly the same
</code></pre>
<p><strong> Filter </strong> will select some elements</p>
<pre><code class="language-scala">val l:List[Int] = List(1,2,3,4);
val l2 = l.map(x =&gt; x * 2).filter(x =&gt; x &gt; 5).map(x =&gt; x + 1)
// 1º map result List(2,4,6,8)
// 2º filter result List(6,8)
// final result List(7,8)
</code></pre>
<p><strong> Useful functions </strong> there are many useful functions over collections.</p>
<put here some examples>

<p><strong> reduce </strong> will transform a list[A] into an A, this method assumes that the List,
are not empty.</p>
<pre><code class="language-scala">// Lets see the reduce signure:
def reduce[A1 &gt;: A](op: (A1, A1) ⇒ A1): A1
// ...
val l:List[Int] = List(1,2,3,4);
l.reduce{ (a,b) =&gt; a + b }
// will give 9
List[Int]().reduce{ (a,b) =&gt; a + b }
// empty list will throw excepton!!
</code></pre>
<p><strong> foldRight and foldLeft </strong> is like reduce, but more useful.</p>
<pre><code class="language-scala">// Lets see the signures:
def foldRight[B](z: B)(op: (A, B) ⇒ B): B
// will produce something like &#39;op(x_1, op(x_2, ... op(x_n, z)...))&#39;
def foldLeft[B](z: B)(f: (B, A) ⇒ B): B
// will produce something like &#39;op(...op(z, x_1), x_2, ..., x_n)&#39;
</code></pre>
<p>With the fold we can transform a list into objects, example:</p>
<pre><code class="language-scala">val l:List[Int] = List(1,2,3,4);
l.foldLeft(&quot;0&quot;){(z:String, i:Int) =&gt; z + &quot;,&quot; +  i.toString }
// will produce 0,1,2,3,4
// op(op(op(op(&quot;0&quot;, 1), 2 ), 3), 4)
</code></pre>
<pre><code class="language-scala">val l:List[Int] = List(1,2,3,4);
l.foldRight(&quot;0&quot;){(i:Int, z:String) =&gt; z + &quot;,&quot; + i.toString  }
// will produce 0,4,3,2,1
// op(1,op(2,op(3,op(4,&quot;0&quot;))))
</code></pre>
<p><a name="-implicit-variable"></a></p>
<h3>Implicit Variable</h3><p>Implicit variables are a mechanism to avoid always be passing some variable into a function, normally this is very useful on recursive functions.</p>
<pre><code class="language-scala">// also on this example we are using Scala string processing
def f(name:String)(implicit location:String) = s&quot;hello $name, you are at $location&quot;
implicit  val l = &quot;lisbon&quot;
f(&quot;rui&quot;)
// will give &#39;hello rui, you are at lisbon&#39;
f(&quot;rui&quot;)(&quot;porto&quot;)
// will give &#39;hello rui, you are at porto&#39;
</code></pre>
<p>The value l is been declared as implicit of type String, when ever its needed a Implicit String the value l will be used.</p>
<p>We can import implicit variable and use in other context:</p>
<pre><code class="language-scala">object o1{ implicit val i = 500}
def f(implicit h:Int) = h * 2
// importing the variable i
import o1._
// we are calling the function f (no parentheses need)
// and with the result call toString
printf(f.toString);
</code></pre>
<p>Also we can have more than one variable as implicit input:</p>
<pre><code class="language-scala">def f(i:Int)(implicit k:Int, s:String):String = i match {
  case 0 =&gt; s + k
  case _ =&gt; f(i - 1)
}
implicit val i = 100;
implicit val i = &quot;i has &quot;;
f(50)
</code></pre>
<p><a name="-implicit-method"></a></p>
<h3>Implicit Method</h3><p>Implicit methods are used to convert a variable into other</p>
<p><a name="-implicit-class"></a></p>
<h3>Implicit Class</h3><p>Implicit class are used to lay methods in certain types</p>
<p><a name="scala-script"></a></p>
<h2>Scala as a Script language</h2><p>WARNING: Not writed yet
TODO: write this topic.</p>
<p><a name="type-inference"></a></p>
<h3>Type Inference</h3><p>WARNING: Not writed yet
TODO: write this topic.</p>
<p><a name="syntax-sugar"></a></p>
<h3>Syntax Sugar</h3><p>WARNING: Not writed yet
TODO: write this topic.</p>
<!---

# ,"#scala-concurrency":{"title":"Scala Concurrency","sub":{"#futures-promises":{"title":"Futures and Promises"},"#todo":{"title":"todo: add topics here"}}},"#scala-reflection":{"title":"Scala Reflection","sub":{"#universe":{"title":"Universe"},"#todo2":{"title":"Add something here"}}},"#scala-macros":{"title":"Scala Macros","sub":{"#whitebox-blackbox":{"title":"Whitebox and blackbox macros"},"#annotations-macros":{"title":"Annotations Macros"}}},"#scala-xml":{"title":"Scala XML"},"#scala-string":{"title":"Scala String Processing"}   }

# <a name="scala-cool"></a>
# ## Scala as a cool language
#
# WARNING: Not writed yet
# TODO: write this topic.
# 
# <a name="scala-concurrency"></a>
# ### Scala Concurrency
# 
# WARNING: Not writed yet
# TODO: write this topic.
# 
# <a name="futures-promises"></a>
# #### Futures and Promises
# 
# WARNING: Not writed yet
# TODO: write this topic.
# 
# <a name="todo"></a>
# #### @todo: add topics here
# 
# WARNING: Not writed yet
# TODO: write this topic.
# 
# <a name="scala-reflection"></a>
# ### Scala Reflection
# 
# WARNING: Not writed yet
# TODO: write this topic.
# 
# <a name="universe"></a>
# #### Universe
# 
# WARNING: Not writed yet
# TODO: write this topic.
# 
# <a name="todo2"></a>
# #### Add something here
# 
# WARNING: Not writed yet
# TODO: write this topic.
# 
# <a name="scala-macros"></a>
# ### Scala Macros
# 
# WARNING: Not writed yet
# TODO: write this topic.
# 
# <a name="whitebox-blackbox"></a>
# #### Whitebox and blackbox macros
# 
# WARNING: Not writed yet
# TODO: write this topic.
# 
# <a name="annotations-macros"></a>
# #### Annotations Macros
# 
# WARNING: Not writed yet
# TODO: write this topic.
# 
# <a name="scala-xml"></a>
# ### Scala XML
# 
# WARNING: Not writed yet
# TODO: write this topic.
# 
# <a name="scala-string"></a>
# ### Scala String Processing
# 
# WARNING: Not writed yet
# TODO: write this topic.
# 
--></put><!--div(class='footer')--><!--div(class='pure-menu pure-menu-horizontal')--><!--  ul--><!--    li(class='pure-menu-item'): a(href='/' class='pure-menu-link') cenas1--><!--    li(class='pure-menu-item'): a(href='/' class='pure-menu-link') cenas2--><!--    li(class='pure-menu-item'): a(href='/' class='pure-menu-link') cenas3--></div></div><script src="/js/lib/prism.js"></script><script src="/js/ui.js"></script></body></html>